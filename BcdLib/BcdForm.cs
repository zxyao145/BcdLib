using System;
using System.ComponentModel;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.JSInterop;
using BcdLib.Core;
using BcdLib.Extensions;
using Microsoft.AspNetCore.Components.Rendering;
using IComponent = Microsoft.AspNetCore.Components.IComponent;

namespace BcdLib
{
    public abstract class BcdForm : IComponent, IDisposable
    {
        public const string Prefix = "bcd-form";

        private IJSRuntime JsRuntime => BcdServices.JsRuntime;

        /// <summary>
        /// IServiceScope for accept dependent injection services.
        /// <para>
        ///     If you <b>use</b> ServiceScope in the subclass, note that it will be released at Dispose.
        /// </para>
        /// <para>
        ///     If you <b>don't use</b> ServiceScope in the subclass, you can still use <c>ShowAsync</c> after Disposed
        /// </para>
        /// </summary>
        protected readonly IServiceScope ServiceScope;

        /// <summary>
        /// IServiceProvider for accept dependent injection services.
        /// </summary>
        protected readonly IServiceProvider ServiceProvider;

        protected BcdForm(string name = null)
        {
            ServiceProvider = BcdServices.ServiceProvider;
            ServiceScope = BcdServices.ServiceProvider.CreateScope();
            InitComponent();
            RenderFragment = builder => BuildRenderTree(builder);
            if (!string.IsNullOrWhiteSpace(name))
            {
                this.Name = name;
            }
        }

        #region form properties

        /// <summary>
        /// Indicates whether it needs to be re rendered
        /// </summary>
        internal bool ShouldReRender { get; set; } = true;

        /// <summary>
        /// all public property should be proxy to BcdFormOptions
        /// </summary>
        internal BcdFormOptions Options { get; set; } = new BcdFormOptions();

        /// <summary>
        /// The width of the form, in pixels
        /// </summary>
        public int Width
        {
            get => Options.Width;
            set
            {
                Options.Width = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Where the form is minimized
        /// </summary>
        public MinPosition MinPosition
        {
            get => Options.MinPosition;
            set
            {
                Options.MinPosition = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// form body's style
        /// </summary>
        public string BodyStyle
        {
            get => Options.BodyStyle;
            set
            {
                Options.BodyStyle = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Remove from DOM when closing. Default is true.
        /// If <c>DestroyOnClose = false</c>, be sure to use a global variable to accept the instance of BcdForm
        /// </summary>
        public bool DestroyOnClose
        {
            get => Options.DestroyOnClose;
            set
            {
                Options.DestroyOnClose = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Unique identification, it will be used as the Id attribute of the form root DOM. If it is not defined, it will be generated by default
        /// </summary>
        public string Name
        {
            get => Options.Name;
            set
            {
                Options.Name = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow header to be displayed. Default is true
        /// </summary>
        public bool EnableHeader
        {
            get => Options.EnableHeader;
            set
            {
                Options.EnableHeader = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow Mask to be displayed. Default is false
        /// </summary>
        public bool ShowMask
        {
            get => Options.ShowMask;
            set
            {
                Options.ShowMask = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Whether to close the form when the mask is clicked, if ShowMask is true.
        /// </summary>
        public bool MaskClosable
        {
            get => Options.MaskClosable;
            set
            {
                Options.MaskClosable = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// the style of Mask, if <paramref name="ShowMask"/> is true.
        /// </summary>
        public string MaskStyle
        {
            get => Options.MaskStyle;
            set
            {
                Options.MaskStyle = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// the title of form. Default value is BcdForm
        /// </summary>
        public string Title
        {
            get => Options.Title;
            set
            {
                Options.Title = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow minimization
        /// </summary>
        public bool MinimizeBox
        {
            get => Options.MinimizeBox;
            set
            {
                Options.MinimizeBox = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow maximum
        /// </summary>
        public bool MaximizeBox
        {
            get => Options.MaximizeBox;
            set
            {
                Options.MaximizeBox = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Allow drag
        /// </summary>
        public bool Draggable
        {
            get => Options.Draggable;
            set
            {
                Options.Draggable = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Drag is only allowed in the viewport, if <paramref name="Draggable"/> is true.
        /// </summary>
        public bool DragInViewport
        {
            get => Options.DragInViewport;
            set
            {
                Options.DragInViewport = value;
                ShouldReRender = true;
            }
        }

        /// <summary>
        /// Whether the form is visible or not
        /// </summary>
        public bool Visible { get; private set; }

        /// <summary>
        /// Whether the form has been removed from DOM
        /// </summary>
        public bool HasDestroyed { get; private set; } = true;

        /// <summary>
        /// The form's state: maximize, minimize or normalize
        /// </summary>
        public FormState FormState
        {
            get => _formState;
            private set
            {
                LastState = _formState;
                _formState = value;
                ShouldReRender = true;
            }
        }

        #endregion


        internal string GetHeaderCls()
        {
            return Draggable ? "draggable" : "";
        }

        internal string GetStyle()
        {
            return Visible ? "" : "display:none;";
        }

        internal string GetFormStyle()
        {
            if (_firstRender)
            {
                var sty = $"width: {Width}px;";
                _lastNormal = sty;
            }

            return _lastNormal;
        }

        private string _lastNormal;
        private bool _firstRender = true;


        internal RenderFragment RenderFragment { get; init; }


        #region interface implement

        private RenderHandle _renderHandle;

        /// <inheritdoc />
        public void Attach(RenderHandle renderHandle)
        {
            if (_renderHandle.IsInitialized)
            {
                _renderHandle = renderHandle;
                throw new InvalidOperationException($"The render handle is already set. Cannot initialize a {nameof(ComponentBase)} more than once.");
            }
            _renderHandle = renderHandle;
        }

        /// <inheritdoc />
        public Task SetParametersAsync(ParameterView parameters)
        {
            if (_firstRender)
            {
                _firstRender = false;
                _renderHandle.Render(RenderFragment);
            }
            else if (ShouldReRender)
            {
                _renderHandle.Render(RenderFragment);
            }
            return Task.CompletedTask;
        }

        #endregion


        #region Show

        /// <summary>
        /// Trigger before displaying form. The display can be cancelled by CancelEventArgs.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnShowingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Show form
        /// </summary>
        /// <returns></returns>
        public async Task ShowAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnShowingAsync(eventArgs);
            if (eventArgs.Cancel)
            {
                return;
            }

            if (!Visible)
            {
                Visible = true;
                if (HasDestroyed)
                {
                    HasDestroyed = false;
                    await BcdFormContainer.BcdFormContainerInstance.AppendFormAsync(this);
                }
                await StateHasChangedAsync();
            }
        }

        #endregion

        #region close

        /// <summary>
        /// Trigger before closing form. The close can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnClosingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }

        /// <summary>
        /// Trigger before the form destroying (removing) from DOM. The destroy Can be cancelled by CancelEventArgs
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        protected virtual Task OnDestroyingAsync(CancelEventArgs e)
        {
            return Task.CompletedTask;
        }


        /// <summary>
        /// Close form.
        /// <para>
        ///     If you want to call the <b>base.CloseAsync</b> in the component, be sure to use <b>pure event handlers</b>! Just like:
        ///     <code>
        ///         @onclick="EventUtil.AsNonRenderingEventHandler(async => { await base.CloseAsync(); })"
        ///     </code>
        /// </para>
        /// <para>
        ///     It's in <b>EventUtil</b> class and is provided by SteveSandersonMs
        /// </para>
        /// </summary>
        /// <returns></returns>
        public async Task CloseAsync()
        {
            CancelEventArgs eventArgs = new CancelEventArgs(false);
            await OnClosingAsync(eventArgs);

            if (eventArgs.Cancel)
            {
                return;
            }

            if (Visible)
            {
                Visible = false;
                await StateHasChangedAsync();

                if (DestroyOnClose && !HasDestroyed)
                {
                    HasDestroyed = true;
                    eventArgs = new CancelEventArgs(false);
                    await OnDestroyingAsync(eventArgs);

                    if (eventArgs.Cancel)
                    {
                        return;
                    }
                    await BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);

                    //await InvokeStateHasChangedAsync();
                }
            }
        }

        #endregion

        #region min max

        /// <summary>
        /// last form state
        /// </summary>
        private FormState LastState { get; set; }

        private FormState _formState;

        internal string GetFormState()
        {
            return IsMin()
                ? $"{FormState.ToCls()} {MinPosition.ToCls()}"
                : FormState.ToCls();
        }

        /// <summary>
        /// Minimize form
        /// </summary>
        public async Task OnMinBoxClick()
        {
            await ChangeFormStateAsync(FormState.Min);
        }

        /// <summary>
        /// Maximize form
        /// </summary>
        public async Task OnMaxBoxClick()
        {
            await ChangeFormStateAsync(FormState.Max);
        }

        private static readonly Func<BcdForm, Task>[][] _stateChangeFunc = new Func<BcdForm, Task>[][]
        {
            // normal to others
            new Func<BcdForm,Task>[]
            {
                (form) => Task.CompletedTask,
                (form) =>
                {
                    form.FormState = FormState.Min;
                    BcdFormContainer.MinFormCount += 1;
                    return Task.CompletedTask;
                },
                async (form) =>
                {
                    form.FormState = FormState.Max;
                    await form.JsRuntime.InvokeVoidAsync(JsInteropConstants.DisableBodyScroll);
                }
            },
            // min to others
            new Func<BcdForm,Task>[]
            {
                (form) => Task.CompletedTask,
                (form) => Task.CompletedTask,
                async (form) =>
                {
                    // restore
                    BcdFormContainer.MinFormCount -= 1;
                    if (form.LastState.IsNormal())
                    {
                        form.FormState = FormState.Normal;
                    }
                    else if (form.LastState.IsMax())
                    {
                        form.FormState = FormState.Max;
                        await form.JsRuntime.InvokeVoidAsync(JsInteropConstants.DisableBodyScroll);
                    }
                    else
                    {
                        BcdFormContainer.MinFormCount += 1;
                    }
                }
            },
            // max to others
            new Func<BcdForm,Task>[]
            {
                (form) => Task.CompletedTask,
                async (form) =>
                {
                    form.FormState = FormState.Min;
                    BcdFormContainer.MinFormCount += 1;
                    await form.JsRuntime.InvokeVoidAsync(JsInteropConstants.EnableBodyScroll);
                },
                // max -> max == normal
                async (form) =>
                {
                    form.FormState = FormState.Normal;
                    await form.JsRuntime.InvokeVoidAsync(JsInteropConstants.EnableBodyScroll);
                }
            },
        };

        private async Task ChangeFormStateAsync(FormState state)
        {
            Func<BcdForm, Task> func = _stateChangeFunc[(int)FormState][(int)state];
            await func(this);
        }

        /// <summary>
        /// Determine whether the form is minimized
        /// </summary>
        /// <returns></returns>
        public bool IsMin()
        {
            return FormState.IsMin();
        }

        /// <summary>
        /// Determine whether the form is maximized
        /// </summary>
        /// <returns></returns>
        public bool IsMax()
        {
            return FormState.IsMax();
        }

        /// <summary>
        /// Determine whether the form is normalized
        /// </summary>
        /// <returns></returns>
        public bool IsNormal()
        {
            return FormState.IsNormal();
        }

        #endregion

        #region Adapter or proxy

        /// <summary>
        /// jsRuntime.InvokeVoidAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async Task JsInvokeVoidAsync(string func, params object[] args)
        {
            if (BcdServices.TryGetJsRuntime(out var jsRuntime))
            {
                await jsRuntime.InvokeVoidAsync(func, args);
            }
            else
            {
                throw new Exception("cannot access IJsRuntime to invoke js");
            }
        }

        /// <summary>
        /// jsRuntime.InvokeAsync adapter
        /// </summary>
        /// <param name="func"></param>
        /// <param name="args"></param>
        /// <returns></returns>
        protected async ValueTask<T> JsInvokeAsync<T>(string func, params object[] args)
        {
            if (BcdServices.TryGetJsRuntime(out var jsRuntime))
            {
                return await jsRuntime.InvokeAsync<T>(func, args);
            }
            else
            {
                throw new Exception("cannot access IJsRuntime to invoke js");
            }
        }

        /// <summary>
        /// it is implemented internally through <c>InvokeStateHasChanged</c> method
        /// </summary>
        protected void StateHasChanged()
        {
            BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChanged();
        }

        /// <summary>
        /// it is implemented internally through <c>InvokeStateHasChangedAsync</c> method
        /// </summary>
        protected Task StateHasChangedAsync()
        {
            return BcdFormContainer.BcdFormContainerInstance.InvokeStateHasChangedAsync();
        }

        /// <summary>
        /// StateHasChanged adapter
        /// </summary>
        [Obsolete("replcae this with StateHasChanged()")]
        protected void InvokeStateHasChanged()
        {
            StateHasChanged();
        }

        /// <summary>
        /// InvokeAsync(StateHasChanged) adapter
        /// </summary>
        /// <returns></returns>
        [Obsolete("replcae this with StateHasChangedAsync()")]
        protected Task InvokeStateHasChangedAsync()
        {
            return StateHasChangedAsync();
        }

        #endregion

        #region dispose

        /// <summary>
        /// Has the object been released
        /// </summary>
        protected bool IsDisposed { get; private set; }

        /// <summary>
        /// If rewriting, be sure to base.Dispose Call this function
        /// </summary>
        /// <param name="disposing"></param>
        protected virtual void Dispose(bool disposing)
        {
            if (!IsDisposed)
            {
                if (disposing)
                {
                    ServiceScope?.Dispose();
                    // destroy DOM from the Document
                    _ = BcdFormContainer.BcdFormContainerInstance.RemoveFormAsync(this);
                }
            }
            IsDisposed = true;
        }

        /// <summary>
        /// dispose the form
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        ~BcdForm()
        {
            // Finalizer calls Dispose(false)
            Dispose(false);
        }

        #endregion


        internal async Task AfterRenderAsync()
        {
            if (_firstRender && Draggable)
            {
                await JsInvokeVoidAsync(JsInteropConstants.EnableDraggable,
                    $"#{Name} .bcd-form-header .bcd-form-title", $"#{Name} .bcd-form", DragInViewport);
            }

            if (IsMin())
            {
                var lastNormal = await JsInvokeAsync<string>(JsInteropConstants.MinResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }
            else if (IsMax())
            {
                var lastNormal = await JsInvokeAsync<string>(JsInteropConstants.MaxResetStyle, $"#{Name}", LastState.IsNormal());
                if (LastState.IsNormal())
                {
                    _lastNormal = lastNormal;
                }
            }


            // ReSharper disable once MethodHasAsyncOverload
            OnAfterRender(_firstRender);
            await OnAfterRenderAsync(_firstRender);
            if (_firstRender)
            {
                _firstRender = false;
            }

            ShouldReRender = false;
        }

        protected abstract void InitComponent();

        protected virtual void BuildRenderTree(RenderTreeBuilder builder)
        {
        }

        
        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual void OnAfterRender(bool firstRender)
        {
        }


        /// <summary>
        /// it will trigger in OnAfterRenderAsync
        /// </summary>
        /// <param name="firstRender">Is the form rendered for the first time</param>
        protected virtual Task OnAfterRenderAsync(bool firstRender) => Task.CompletedTask;

    }
}
